import * as Meeco from '@meeco/sdk';
//import { Keypair, KeypairResponse } from '@meeco/keystore-api-sdk';
import { Connection, Item } from '@meeco/vault-api-sdk';
//import * as cryppo from '@meeco/cryppo';
import * as m from 'mithril';

import environment from '../environment';
import { serviceUserAuth, servicePublicKey } from '../serviceUser';

import { TemplateSchemaStore, ItemTemplate } from './TemplateSchemaStore';
import JSONComponent from './JSONComponent.js';
import API from './API';
import { FakeAPI } from './FakeAPI';

const USER_AUTH_DATA = 'user_auth_data';

// Active user's AuthData from SessionStorage.
let AuthData = JSON.parse(sessionStorage.getItem(USER_AUTH_DATA) || '{}');
if (AuthData.data_encryption_key) {
  AuthData.data_encryption_key = Meeco.EncryptionKey.fromSerialized(AuthData.data_encryption_key);
  AuthData.key_encryption_key = Meeco.EncryptionKey.fromSerialized(AuthData.key_encryption_key);
  AuthData.passphrase_derived_key = Meeco.EncryptionKey.fromSerialized(AuthData.passphrase_derived_key);
}

let App = {
  authToken: AuthData.vault_access_token,
  userDEK: AuthData.data_encryption_key,
  templates: undefined,
  loginService: new Meeco.UserService(environment),

  login: async function(userSecret: string, userPass: string) {
    console.log('begin auth');
    AuthData = await App.loginService.get(userPass, userSecret);
    console.log('finished auth');

    sessionStorage.setItem(USER_AUTH_DATA, JSON.stringify(AuthData));
    App.authToken = AuthData.vault_access_token;
    App.userDEK = AuthData.data_encryption_key.key;
    App.templates = new TemplateSchemaStore(environment.vault.url, App.authToken, environment.vault.subscription_key);
  },
  logout: function() {
    sessionStorage.removeItem(USER_AUTH_DATA);
    App.authToken = '';
    App.userDEK = '';
  },
};

// Default load
if (AuthData.vault_access_token) {
  App.templates = new TemplateSchemaStore(environment.vault.url, AuthData.vault_access_token, environment.vault.subscription_key);
}

function makeAuthHeaders(token: string) {
  return { 'Authorization': 'Bearer ' + token,
           'Meeco-Subscription-Key': environment.keystore.subscription_key };
}

function LoginComponent() {
  let secret = "1.xB2dP9.7JXpPj-qocZLf-MjT1XN-ULtA8H-8szT1f-SQz4U1-LifbZ6-ff";
  let pass = '';

  return {
    view: () =>
          m('form.pure-form', { onsubmit: (e: any) => {
              e.preventDefault();
              App.login(secret, pass);
          }}, [
              m('input', { type: "text", placeholder: "secret", value: secret, oninput: (e: any) => secret = e.target.value }),
              m('input', { type: "password", oninput: (e: any) => pass = e.target.value }),
              m('button[type="submit"].pure-button', 'Login'),
              m('button.pure-button', { onclick: () => App.logout() }, 'Logout'),
              m('input', { type: "text", placeholder: "Token", value: App.authToken, oninput: (e: any) => App.authToken = e.target.value }),
          ])
  };
}

/**
 * Create an ItemTemplate representing the given form.
 * @param formId
 */
function makeFormTemplate(formId: string): Promise<ItemTemplate> {

  let fieldNames = [];
  document.querySelectorAll('#' + formId + ' input').forEach((x: any) => fieldNames.push(x.name));

  // TODO may need a uniqueness component for template name
  return App.templates.saveUnlessExists({
    name: formId,
    label: 'Autogenerated form',
    slots_attributes: fieldNames.map(n => {return {label: n, slot_type_name: 'key_value'}})
  });
}

function collectSlotData(): Array<any> {
  let fields = [];
  document.querySelectorAll('#test-form input').forEach((x: Element) => fields.push({name: x.nodeName, value: x.nodeValue}));
  return fields;
}

async function connectHandler(invitationToken: string, api: API): Promise<Connection> {
  const keyPair = await api.getOrCreateKeyPair('dog', AuthData.key_encryption_key.key, AuthData.keystore_access_token);

  // TODO cannot establish a connection...
  return await Meeco.vaultAPIFactory(environment)(AuthData).ConnectionApi.connectionsPost({
      public_key: {
        keypair_external_id: keyPair.external_identifiers[0],
        public_key: keyPair.public_key,
      },
      connection: {
        encrypted_recipient_name: 'nothing here',
        invitation_token: invitationToken,
      },
    })
    .then(res => res.connection);
}

function meecoForm(divId: string, formSpec: Record<string, object>) {
  // TODO add for/name/id to inputs
  const controls = Object.entries(formSpec).map(([label, fieldSpec]) => {
    return m('.pure-control-group', [
      m('label', label),
      m('input', fieldSpec)
    ])
  });

  const component = {
    view: () => m('form.pure-form.pure-form-aligned', [
      m('h3', 'Meeco Form'),
      ...controls,
      m('.pure-controls', [
        m('label', 'Expires'),
        m('input', { type: 'date', value: (new Date()).toLocaleDateString() }),
        m('button.pure-button', 'Share'),
        m('button.pure-button', 'Broadcast')
      ])
    ])
  };

  m.mount(document.getElementById(divId), component);
}

function drawExistingItem(item: Item) {
  console.log('autofill items');
  document.getElementById('test-form').insertAdjacentHTML('afterend', '<button>Autofill</button>');
  m.mount(document.getElementById('item-output'), JSONComponent(item));
}

function drawTemplates(templates: ItemTemplate[]) {
  const component = {
    view: () => templates.map(t => m('li.pure-menu-item', m('a.pure-menu-link', t.label)))
  }
  m.mount(document.getElementById('templates-list'), component);
}

// Entry point
window.onload = () => {
  document.getElementById('test-form').hidden = true;

  m.mount(document.getElementById('auth'), LoginComponent);

  const api = new API(environment);

  // api.createInvite(serviceUserAuth.vault_access_token, serviceUserAuth.keystore_access_token, 'funny_hat', 'fake-name');
//   api.createInviteFromKey(serviceUserAuth.vault_access_token, servicePublicKey, 'funny_hat', 'Aes256Gcm.6xtPqA==.LS0tCml2OiAhYmluYXJ5IHwtCiAgWG9mS2U1WTBodmJPbVlrRAphdDogIWJpbmFyeSB8LQogIGErMi95SXZ2dnBMQytmeVdmYjVWekE9PQphZDogbm9uZQo=');

  document.getElementById('ad-target').onclick = () => {
    alert('I send connect request!');
    // Get Invite
    const inviteToken = document.getElementById('ad-target').attributes.getNamedItem('data-meeco-invite').value;

    // let connection = connectHandler(inviteToken, api).then(c => {
    //   // get back recipient_id
    //   console.log('connection is');
    //   console.log(c);
    //   return c;
    // });

    // let recipient = connection.user_id;
    // also some form_id for 'next_steps'
    // then show form
    document.getElementById('test-form').hidden = false;

    const templateName = 'fake_template';

    drawTemplates(App.templates.templates());

      let template = App.templates.getTemplateByName(templateName);

      // Items may exist!
      api.lookupItem(template.id, AuthData.vault_access_token).then(existingItems => {

        if (existingItems.length > 0) {
          console.log('autofill');
          document.getElementById('test-form').insertAdjacentHTML('afterend', '<button>Autofill</button>');
        }

        document.getElementById('submit-target').onclick = e => {
          e.preventDefault();
          // TODO Create Connect
          // const service = Meeco.ConnectionService(environment).createConnection({from: _, to: _, options: _});

          api.createItem(templateName, collectSlotData()).then(d => {
            console.log(d);
            m.mount(document.getElementById('item-output'), JSONComponent(d));
          });
          // Once created -> share with Org/Service

          // TODO
          // Get {OrgId/service/Id}.agent_id

          // TODO Create Connect

          // TODO Create Share
          // TODO Send Invite
        };

      });
    });
  };
}
